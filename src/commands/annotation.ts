/**
 * Annotation Commands
 * Handles: add, remove, toggle, edit, view, undo
 */

import * as vscode from 'vscode';
import { AnnotationManager } from '../managers';
import { AnnotationItem } from '../ui';
import { CommandContext } from './index';
import { CopilotExporter } from '../copilotExporter';

/**
 * Helper to convert Tag to string
 */
function tagToString(tag: any): string {
    return typeof tag === 'string' ? tag : tag.id;
}

export function registerAnnotationCommands(
    context: vscode.ExtensionContext,
    cmdContext: CommandContext
) {
    const { annotationManager, sidebarWebview, ANNOTATION_COLORS } = cmdContext;

    // Command: Add annotation to selected text
    const addAnnotationCommand = vscode.commands.registerTextEditorCommand(
        'annotative.addAnnotation',
        async (editor: vscode.TextEditor) => {
            const selection = editor.selection;
            if (selection.isEmpty) {
                vscode.window.showWarningMessage('Please select some text to annotate.');
                return;
            }

            // Get comment via input box
            const comment = await vscode.window.showInputBox({
                prompt: 'Enter annotation comment',
                placeHolder: 'What do you want to note about this code?',
                validateInput: (value) => {
                    return value.trim().length === 0 ? 'Comment cannot be empty' : null;
                }
            });

            if (!comment) {
                return;
            }

            // Get tags via quick pick (multi-select)
            const availableTags = [
                'bug', 'performance', 'security', 'style',
                'improvement', 'docs', 'question', 'ai-review'
            ];

            const selectedTags = await vscode.window.showQuickPick(availableTags, {
                placeHolder: 'Select tags (optional)',
                canPickMany: true
            });

            // Get color via quick pick
            const selectedColor = await vscode.window.showQuickPick(ANNOTATION_COLORS, {
                placeHolder: 'Choose a color (visual preference only)'
            });

            const color = selectedColor?.value || '#ffc107'; // Default to yellow

            await annotationManager.addAnnotation(
                editor,
                selection,
                comment,
                selectedTags || [],
                color
            );
            sidebarWebview.refreshAnnotations();
            vscode.window.showInformationMessage('Annotation added successfully!');
        }
    );

    // Command: Add annotation from template
    const addAnnotationFromTemplateCommand = vscode.commands.registerTextEditorCommand(
        'annotative.addAnnotationFromTemplate',
        async (editor: vscode.TextEditor) => {
            const selection = editor.selection;
            if (selection.isEmpty) {
                vscode.window.showWarningMessage('Please select some text to annotate.');
                return;
            }

            // Show template picker
            const template = await vscode.window.showQuickPick([
                {
                    label: 'Review AI-Generated Code',
                    comment: 'Review this AI-generated code for correctness and best practices',
                    tags: ['ai-review', 'review'],
                    detail: 'For code generated by Copilot, ChatGPT, or other AI tools'
                },
                {
                    label: 'Explain This Code',
                    comment: 'Explain how this code works and what it does',
                    tags: ['question', 'docs'],
                    detail: 'Ask for explanation of complex code sections'
                },
                {
                    label: 'Optimize This Code',
                    comment: 'Suggest optimizations for better performance',
                    tags: ['performance', 'optimization'],
                    detail: 'Identify performance improvements'
                },
                {
                    label: 'Find Potential Bugs',
                    comment: 'Review this code for potential bugs and edge cases',
                    tags: ['bug', 'review'],
                    detail: 'Look for logical errors and edge cases'
                },
                {
                    label: 'Security Review',
                    comment: 'Check this code for security vulnerabilities',
                    tags: ['security', 'review'],
                    detail: 'Identify security risks and vulnerabilities'
                },
                {
                    label: 'Generate Documentation',
                    comment: 'Generate documentation for this code',
                    tags: ['docs', 'documentation'],
                    detail: 'Create comprehensive code documentation'
                },
                {
                    label: 'Refactor Suggestion',
                    comment: 'Suggest refactoring to improve code quality',
                    tags: ['refactor', 'style'],
                    detail: 'Improve code structure and readability'
                },
                {
                    label: 'Add Tests',
                    comment: 'Suggest unit tests for this code',
                    tags: ['test', 'improvement'],
                    detail: 'Generate test cases and coverage'
                }
            ], {
                placeHolder: 'Select an annotation template',
                matchOnDetail: true
            });

            if (!template) {
                return;
            }

            // Add annotation with template
            await annotationManager.addAnnotation(
                editor,
                selection,
                template.comment,
                template.tags
            );
            sidebarWebview.refreshAnnotations();

            // Ask if user wants to send to Copilot immediately
            const action = await vscode.window.showInformationMessage(
                `Annotation added: ${template.label}`,
                'Ask Copilot Now',
                'Done'
            );

            if (action === 'Ask Copilot Now') {
                const annotations = annotationManager.getAnnotationsForFile(editor.document.uri.fsPath);
                const newAnnotation = annotations[annotations.length - 1];

                if (newAnnotation) {
                    const prompt = await CopilotExporter.formatAnnotationForCopilot(newAnnotation, {
                        contextLines: 5,
                        smartContext: true
                    });

                    await vscode.env.clipboard.writeText(prompt);

                    try {
                        await vscode.commands.executeCommand('workbench.panel.chat.view.copilot.focus');
                        vscode.window.showInformationMessage('Paste into Copilot Chat (Ctrl+V)');
                    } catch {
                        vscode.window.showInformationMessage('Context copied! Open Copilot Chat and paste.');
                    }
                }
            }
        }
    );

    // Command: Remove annotation
    const removeAnnotationCommand = vscode.commands.registerCommand(
        'annotative.removeAnnotation',
        async (item: AnnotationItem) => {
            const confirmed = await vscode.window.showWarningMessage(
                `Are you sure you want to remove this annotation?`,
                'Yes', 'No'
            );

            if (confirmed === 'Yes') {
                await annotationManager.removeAnnotation(item.annotation.id, item.annotation.filePath);
                sidebarWebview.refreshAnnotations();
                vscode.window.showInformationMessage('Annotation removed successfully!');
            }
        }
    );

    // Command: Toggle resolved status
    const toggleResolvedCommand = vscode.commands.registerCommand(
        'annotative.toggleResolved',
        async (item: AnnotationItem) => {
            await annotationManager.toggleResolvedStatus(item.annotation.id, item.annotation.filePath);
            sidebarWebview.refreshAnnotations();

            const status = item.annotation.resolved ? 'unresolved' : 'resolved';
            vscode.window.showInformationMessage(`Annotation marked as ${status}!`);
        }
    );

    // Command: Edit annotation
    const editAnnotationCommand = vscode.commands.registerCommand(
        'annotative.editAnnotation',
        async (item: AnnotationItem) => {
            const annotation = item.annotation;

            // Get updated comment via input box
            const comment = await vscode.window.showInputBox({
                prompt: 'Edit annotation comment',
                value: annotation.comment,
                validateInput: (value) => {
                    return value.trim().length === 0 ? 'Comment cannot be empty' : null;
                }
            });

            if (!comment) {
                return;
            }

            // Get updated color via quick pick
            await vscode.window.showQuickPick(ANNOTATION_COLORS, {
                placeHolder: 'Select a color for this annotation'
            });

            const selectedColor = await vscode.window.showQuickPick(ANNOTATION_COLORS, {
                placeHolder: 'Select a color for this annotation'
            });

            const color = selectedColor?.value || annotation.color || '#ffc107';

            // Get updated tags via quick pick (multi-select)
            const availableTags = [
                'bug', 'performance', 'security', 'style',
                'improvement', 'docs', 'question', 'ai-review'
            ];

            const selectedTags = await vscode.window.showQuickPick(availableTags, {
                placeHolder: 'Select tags (optional)',
                canPickMany: true
            });

            const tagsToUse = selectedTags || (annotation.tags?.map((t: any) => tagToString(t)) || []);
            await annotationManager.editAnnotation(
                annotation.id,
                annotation.filePath,
                comment,
                tagsToUse,
                color
            );
            sidebarWebview.refreshAnnotations();
            vscode.window.showInformationMessage('Annotation updated successfully!');
        }
    );

    // Command: View annotation (read-only)
    const viewAnnotationCommand = vscode.commands.registerCommand(
        'annotative.viewAnnotation',
        async (item: AnnotationItem) => {
            const annotation = item.annotation;

            // Navigate to the annotation
            await vscode.commands.executeCommand('annotative.goToAnnotation', annotation);

            // Show details in information message
            const tagsStr = annotation.tags && annotation.tags.length > 0 ? annotation.tags.join(', ') : 'none';
            const resolvedStr = annotation.resolved ? '✓ Resolved' : '○ Unresolved';

            vscode.window.showInformationMessage(
                `${resolvedStr}\nTags: ${tagsStr}\nComment: ${annotation.comment}`,
                { modal: false }
            );
        }
    );

    // Command: Undo last annotation
    const undoLastAnnotationCommand = vscode.commands.registerCommand(
        'annotative.undoLastAnnotation',
        async () => {
            const undoneAnnotation = await annotationManager.undoLastAnnotation();
            if (undoneAnnotation) {
                sidebarWebview.refreshAnnotations();
                vscode.window.showInformationMessage('Last annotation removed');
            } else {
                vscode.window.showWarningMessage('No annotation to undo');
            }
        }
    );

    return {
        addAnnotationCommand,
        addAnnotationFromTemplateCommand,
        removeAnnotationCommand,
        toggleResolvedCommand,
        editAnnotationCommand,
        viewAnnotationCommand,
        undoLastAnnotationCommand
    };
}
